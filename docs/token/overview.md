---
sidebar_position: 2
---

# Overview

This section describes how the IBC Token solution works and how to use it.

**FIXME/WIP**

## General Overview

One deployed wraplock contract may handle interchain token transfers from any number of native token contracts, and any number of different assets issued on them. One wraptoken contract on the other hand, corresponds to only one native token contract - but again any number of assets issued on it. Each wraplock and wraptoken contract is also restricted to moving tokens between two Antelope chains - considered the native and wrapped sides of the token bridge. To facilitate transfers of both wrapped and native tokens in both directions, the wraplock and wraptoken contracts need to be deployed on both chains, and to facilitate transfers across multiple chains, the contracts need to be deployed to multiple accounts.

**TODO:** <diagrams may be useful here, or perhaps a better description above>

## Initialization

> **_NOTE_**: This section is mostly for blockchain infrastructure operators (i.e. Block Producers) that are deploying the IBC Token solution to their blockchain. But it may also be useful or interesting to DApp developers, to get the full picture.

The wraplock contract is deployed on the chain on which the native token contracts reside (chain A). It is initialized with the chain id of both networks involved in this token bridge, and the account of the bridge contract which will be used to verify cryptographic proofs. Each native token contract to be connected to the token bridge is added to this contract, along with its corresponding wraptoken contract on the destination chain (chain B).

The wraptoken contract is deployed on the chain on which the wrapped tokens will be issued (chain B). As with the wraplock contract it is initialized with the chain id of both networks involved in this token bridge, the account of the bridge contract which will be used to verify cryptographic proofs, and also the name of the native token contract on chain A to which this contract corresponds.

## Wrapping Tokens (transferring from chain A to B)

A typical transfer action is used to move the native tokens to the wraplock contract account. The beneficiary account on chain B is specified in the memo field. The tokens are locked and the corresponding token reserve balance in the wraplock contract is credited. An inline emitxfer action is also triggered.

The appropriate proof structures are created using the proof server, or another method. These proofs are submitted to one of the issue actions of the wraptoken contract on chain B. They consist of a heavy (issuea) or light (issueb) block proof, plus a proof that the previously mentioned emitxfer action was included in the proven block.

On receiving the proof, the issue action:
performs a search on the processed multiindex table for the presence of the action receipt digest to ensure that this action hasn’t previously been proven
stores the proof structure in RAM
makes an inline call to the appropriate checkproof action on the bridge contract - to verify the proof
adds the action receipt digest to the processed multiindex table to prevent double spending
mints and transfers equivalent wrapped tokens to the beneficiary specified in the emitxfer action generated by the wraplock contract.

## Using Wrapped Tokens

Since the wraptoken contract is modelled on the standard eosio.token contract, wrapped tokens can be transferred between accounts on chain B by Antelope compatible wallets as though they are native assets.

## Unwrapping Tokens (transferring from chain B to A)

Any holder of wrapped tokens may redeem them for native assets by calling the retire action of the wraptoken contract on chain B, specifying the quantity and beneficiary account on chain A. The contract removes the wrapped tokens from supply, and triggers an inline emitxfer action.

Again, the appropriate proof structures are created using the proof server, or another method. These proofs are sent to one of the withdraw actions on chain A. They consist of a heavy (withdrawa) or light (withdrawb) block proof, plus a proof that the previous emitxfer action was included in the proven block.

On receiving the proof, the withdraw action:
performs a search on the processed multiindex table for the presence of the action receipt digest to ensure that this action hasn’t previously been proven
stores the proof structure in RAM
makes an inline call to the appropriate checkproof action on the bridge contract to verify the proof
adds the action receipt digest to the processed multiindex table to prevent double spending
unlocks and transfers equivalent native tokens to the beneficiary specified in the emitxfer action generated by the wraptoken contract.

## Exceptional Situations

In the case that the beneficiary named in the transfer or retire actions doesn’t exist on the target chain, or that the beneficiary account is running contract code which rejects the inbound transfer, one of the cancel actions may be used to return the tokens to the owner on the source chain - cancela for using a heavy proof, and cancelb using a light proof. In order to prevent a possible denial of service attack vector, the cancel actions may only be used at least 15 minutes after the block containing the emitxfer action. This mitigation is necessary because any account may call the issue, withdraw or cancel actions.
